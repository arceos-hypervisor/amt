# 【草稿】ArceOS Modular Tester 极简设计文档

## 1. 目标

提供一个测试服务，允许 ArceOS 的各个模块（也包括 Hypervisor 的各个模块）在 push/pull request 时进行自动化测试。测试脚本由模块的开发者提供，测试由 Github Actions 触发，测试结果也会通过 Github Actions 的方式反馈给开发者。

测试覆盖的架构和toolchain由模块开发者自行决定。当测试包括 x86_64 架构时，测试应该覆盖 Intel 和 AMD 两种处理器。

测试时应该自动同时测试依赖当前模块的其他模块。

## 2. 架构设想

### 2.1 测试的流程

程序的主要部分是一个后端服务，运行在一个服务器上。这个服务器应该有一个公网 IP，可以被 Github Actions 访问。当一个模块的 push/pull request 触发了 Github Actions，Github Actions 会向这个服务器发送一个请求，请求测试这个模块。

后端服务会 clone 或者 pull 这个模块的代码，运行模块提供的测试脚本，然后将测试结果反馈给 Github Actions。

#### 2.1.1 测试脚本的选择

测试脚本有两种选择：

- 直接支持 Github Actions 的测试脚本。这种做法的好处是最小化了适配的工作量，同时 Github Actions 也提供了丰富的工具链，并且 GitHub Actions 本身也能作为额外的测试者一起参与测试；坏处是需要额外的工具支持。
- 一个独立的测试脚本。在这种情况下，GitHub Actions 本身并不需要运行测试，只需要向后端服务发送请求；后端服务也不需要调用额外的工具链，只需要运行测试脚本；坏处是需要额外的工作量。

#### 2.1.2 后端服务和 Github Actions 的通信

最现实的做法是使用 HTTP 协议。后端服务应该提供一个 HTTP 服务器，接收 Github Actions 的请求，然后返回测试结果。

### 2.2 依赖的分析

后端服务应该同时维护模块之间的依赖关系。这个关系应该主要由 Cargo.toml 文件提供。是否需要支持手动指定依赖关系，还有待商榷。

依赖的分析应该精确到分支一级，即，如果模块 A 的 master 分支依赖模块 B 的 master 分支，那么只有当模块 B 的 master 分支发生变化（push 或出现以 master 为 base 的 pull request）时，模块 A 才会被测试。

依赖的深度也是一个问题。目前的想法是，通过分支过滤之后，测试量应该是有限的。如果一个 commit 引起了大量的测试，那么这本身就说明了这个 commit 非常重要。所以可以暂时不考虑依赖的深度。

### 2.3 模块和分支的选择

理论上，任何一个模块的任何一个分支都应该被测试。此处也可以考虑支持一定程度上的黑白名单机制。
